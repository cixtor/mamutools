#!/usr/bin/env ruby
#
# Source Code Management to Package
# http://www.cixtor.com/
# https://github.com/cixtor/mamutools
# http://en.wikipedia.org/wiki/Compression_program
#
# In computer science and information theory, data compression, source coding,
# or bit-rate reduction involves encoding information using fewer bits than the
# original representation. Compression can be either lossy or lossless. Lossless
# compression reduces bits by identifying and eliminating statistical redundancy.
# No information is lost in lossless compression. Lossy compression reduces bits
# by identifying unnecessary information and removing it. The process of reducing
# the size of a data file is popularly referred to as data compression, although
# its formal name is source coding (coding done at the source of the data before
# it is stored or transmitted).
#
# Compression is useful because it helps reduce resources usage, such as data
# storage space or transmission capacity. Because compressed data must be
# decompressed to use, this extra processing imposes computational or other costs
# through decompression; this situation is far from being a free lunch. Data
# compression is subject to a space-time complexity trade-off. For instance, a
# compression scheme for video may require expensive hardware for the video to be
# decompressed fast enough to be viewed as it is being decompressed, and the option
# to decompress the video in full before watching it may be inconvenient or require
# additional storage. The design of data compression schemes involves trade-offs
# among various factors, including the degree of compression, the amount of
# distortion introduced (e.g., when using lossy data compression), and the
# computational resources required to compress and uncompress the data.
#
# New alternatives to traditional systems (which sample at full resolution, then
# compress) provide efficient resource usage based on principles of compressed
# sensing. Compressed sensing techniques circumvent the need for data compression
# by sampling off on a cleverly selected basis.
#
if !ARGV[0].nil? then
	git_path = ARGV[0]
	git_m = git_path.match(/(http|https):\/\/github\.com\/(.*)\/(.*).git/)
	git_m = git_path.match(/.*@(.*):(.*)\/(.*).git/) if git_m.nil?
	if !git_m.nil? then
		git_localname = git_m[3] + '-' + Time.now.to_s.split(' ')[0].gsub('-','')
		git_localfile = "#{git_localname}.tar.bz2"
		puts "\033[1;33m[+] Cloning git repository: #{git_m[2]}/#{git_m[3]} as #{git_localfile}\033[0m"
		if File.exists?(git_localfile) then
			print "\033[1;31m[?] The local file\033[0m \033[1;36m#{git_localfile}\033[0m \033[1;31malready exists, do you want to override it? (y/n) \033[0m"
			override_it = $stdin.gets.to_s.gsub("\n",'')
			if override_it=='y' or override_it=='' then
				File.delete(git_localfile)
			else
				print "    Fill the filename for the compressed version of the repository #{git_localname}: "
				git_localname = $stdin.gets.to_s.gsub("\n",'')
				git_localfile = "#{git_localname}.tar.bz2"
			end
		end
		system("git clone #{git_path} #{git_localname} && tar -c #{git_localname} | bzip2 > #{git_localname}.tar.bz2 && rm -rf #{git_localname}");
		puts "\033[1;33m[+] Download and compression finished\033[0m"
		system("ls -lhas #{git_localname}.tar.bz2")
	end
else
	puts "Usage: #{__FILE__} https://github.com/username/project.git"
end
#